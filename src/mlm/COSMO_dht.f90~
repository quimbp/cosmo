

PROGRAM COSMO_DHT

  USE netcdf        !Required to manage NetCDF files

  IMPLICIT NONE     !para que no se declaren variables de forma implicita


  !!**********************************************************************
  !!*************  Constantes del programa *******************************
  !!**********************************************************************
  INTEGER, PARAMETER :: maxlen= 100  !! longitud máxima de caracteres a leer


  !!*********************************************************************
  !!*****   variables globales del programa  ****************************
  !!*********************************************************************
  


  LOGICAL :: debugging  !! activate debugging messages
  INTEGER :: status     !! to manage errors when working with files
  
  DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:,:,:) :: mivx, mivy !! matrices donde leo U y V de los datos.
  DOUBLE PRECISION, ALLOCATABLE, DIMENSION (:) :: lat, lon !! vectores para la latitud y longitud de la región de estudio.
  INTEGER, ALLOCATABLE, DIMENSION (:) :: time !! vector para tener los tiempos de cada fotico
  INTEGER :: nx, ny         !! números de datos a lo largo del eje X e Y  
  INTEGER :: time_I, time_F    !! Dias inicial y final de los datos que cargo

  LOGICAL, ALLOCATABLE, DIMENSION (:,:) :: tierra  !! matriz donde guardo las posiciones de tierra
 

  
  


  !! Variables para el tratamiento de los parámetros de entrada
  CHARACTER(:), ALLOCATABLE :: arg   !! argumentos introducidos en línea de comandos



!#################################################
!# The main program starts here
!#################################################

  debugging=.TRUE.

  CALL ReadNetCDF()



  
!*********************************************************************
!********** Definition of local functions and procedures *************
!*********************************************************************

CONTAINS
  
  
!*********************************************************************
!**** Es mi modificación para leer campos de velocidad  U y V   ******
!**** Esta función reserva memoria de forma dinámica tanto para ******
!**** el campo de velocidades final a usar como para la         ******
!**** máscara de tierra (que la intenta deducir del primer mes  ******
!**** leído de los datos. El primer número indica el primer mes ******
!**** que lee y el segundo selecciona el último mes de lectura  ******
!**** de los datos. Carga los datos del Mediterráneo completo.  ******
!**** En el programa principal hay que seleccionar Time_I de    ******
!**** forma que coincida con el primer día del primer mes       ******
!**** leído y time_F de forma que sea mayor al último día leído.******
!*********************************************************************

SUBROUTINE ReadNetCDF()
  CHARACTER (len = *), PARAMETER :: UNITS = "units" !To check the units attributes
  CHARACTER (len = *), PARAMETER :: VELOCITY_UNITS = "m s-1" ! To check velocity units
  CHARACTER (len = *), PARAMETER :: LATITUDE_UNITS = "degrees_north" !To check latitude units 
  CHARACTER (len = *), PARAMETER :: LONGITUDE_UNITS = "degrees_east" !To check longitude units
  LOGICAL :: finalizar  !! boolean variable to control end condition in loops
  CHARACTER(:), ALLOCATABLE :: time_units  !! to check the time units
  CHARACTER (len = maxlen)  :: attribute  !! to check unit of variables
  CHARACTER(:), ALLOCATABLE :: ufile !! input file for U field
  CHARACTER(:), ALLOCATABLE :: vfile !! input file for V filed
  CHARACTER(nf90_max_name) :: uname !! name for variable containing U field in nc file
  CHARACTER(nf90_max_name) :: vname !! name for variable containing V field in nc file
  CHARACTER(nf90_max_name) :: tname !! name for variable containing time in nc file
  CHARACTER(nf90_max_name) :: lonname !! name for variable containing longitudes in nc file
  CHARACTER(nf90_max_name) :: latname !! name for variable containing latitudes in nc file


 ! CHARACTER (len = 50) :: nombrevariable  ! variable auxiliar para saber el numero de dias del mes
  
 ! INTEGER, ALLOCATABLE, DIMENSION (:) :: diasmes
  DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:,:,:) :: data_in_velo
 ! DOUBLE PRECISION :: auxiliar 
 ! LOGICAL :: esTierra

  ! Esto es para guardar la IDentidad para el archivo, la variable y su tamaño.
  INTEGER :: ncid, varid, dimID!, ndims_in,nvars_in,ngatts_in,unlimdimid_in,numerodiasmes
  !INTEGER :: diasleidos,mesesleidos, mesInicial,mesFinal 
  INTEGER :: i,j,k

  !pongo los valores por omisión  
  ufile='SAMGIB-PdE-dm-2018051000-2018051223-B2018051000-FC.nc'
  vfile='SAMGIB-PdE-dm-2018051000-2018051223-B2018051000-FC.nc'
  uname='u'
  vname='v'
  tname='time'
  lonname='longitude'
  latname='latitude'
  DO
     CALL get_command_argument(i, arg)
     IF (LEN_TRIM(arg) == 0) EXIT  
     SELECT CASE (arg(1:2))
     CASE ('-U')
        finalizar=.TRUE.
        DO WHILE (finalizar)
           i=i+1 !read parameter for -U option
           CALL get_command_argument(i, arg)
           IF (LEN_TRIM(arg) == 0) EXIT
           IF (arg(1:5).EQ.'file=') THEN
              ufile=arg(6:)
              finalizar=.FALSE.
           END IF
           SELECT CASE (arg(1:2))
           CASE ('u=')
              uname=arg(3:)
              finalizar=.FALSE.   
           CASE ('x=')
              lonname=arg(3:)
              finalizar=.FALSE.
           CASE ('y=')
              latname=arg(3:)
              finalizar=.FALSE.
           CASE ('t=')
              tname=arg(3:)
              finalizar=.FALSE.
           END SELECT
           IF (.NOT.finalizar) THEN
              finalizar=.TRUE.  ! I have read a valid parameter, then I try to read the next
           END IF
        END DO
     CASE ('-V')
        
     END SELECT        
     i = i+1
  END DO

  IF (debugging) THEN
     PRINT*, "file for U field, ", TRIM(ufile)
     PRINT*, "name for variable U in the file, ", TRIM(uname) 
     PRINT*, "name for variable lon in the file, ", TRIM(lonname)
     PRINT*, "name for variable lat in the file, ", TRIM(latname)
     PRINT*, "name for time variable in the file, ", TRIM(tname)
  ENDIF
   !  -U file=roms.nc u=u x=lon y=lat t=time   




  ! Abrimos el archivo. NF90_NOWRITE indica que abrimos el archivo como solo lectura.
  status = nf90_open(ufile, NF90_NOWRITE, ncid) 
  IF (status /= nf90_noerr) CALL handle_error("A problem happened while opening nc file")
  
!******************* LONGITUDES ************************************
  ! Obtenemos la identidad de la variable usando su nombre.
  status = nf90_inq_varid(ncid, lonname, varid)
  IF (status /= nf90_noerr) CALL handle_error("A problem happened getting longitude variable id")
  ! Getting ID for dimension of array
  status = nf90_inq_dimid(ncid, lonname, DimID)
  IF (status /= nf90_noerr) CALL handle_error("A problem happened getting longitude dimension id")
  ! How many values of "longitude" are there?
  status = nf90_inquire_dimension(ncid, DimID, len = nx)
  IF (status /= nf90_noerr) CALL handle_error("A problem happened getting longitude size")
  
  ALLOCATE(lon(0:nx-1),STAT=status)   ! Assigning memory for longitude vector
  IF (status.NE.0) CALL handle_error("A problem happened allocating memory for longitudes")
  ! Read longitude values
  status = nf90_get_var(ncid, varid, lon)
  IF (status /= nf90_noerr) CALL handle_error("A problem happened reading longitude values")
  ! Checking longitude units
  status = nf90_get_att(ncid, varid, UNITS, attribute)
  IF (status /= nf90_noerr) CALL handle_error("A problem happened getting longitude units")
  IF (attribute.NE.LONGITUDE_UNITS) CALL handle_error("Longitude units must be degrees_east")
  IF (debugging) THEN
     PRINT*, "Size of longitude vector ", nx
     PRINT*, "Longitude units, ", TRIM(attribute)
  END IF

!************* LATITUDES *********************************
  ! Obtenemos la identidad de la variable usando su nombre.
  status = nf90_inq_varid(ncid, latname, varid)
  IF (status /= nf90_noerr) CALL handle_error("A problem happened getting latitude variable id")
  ! Getting ID for dimension of array
  status = nf90_inq_dimid(ncid, latname, DimID)
  IF (status /= nf90_noerr) CALL handle_error("A problem happened getting latitude dimension id")
  ! How many values of "latitude" are there?
  status = nf90_inquire_dimension(ncid, DimID, len = ny)
  IF (status /= nf90_noerr) CALL handle_error("A problem happened getting latitude size")
  
  ALLOCATE(lat(0:ny-1),STAT=status)   ! Assigning memory for latitude vector
  IF (status.NE.0) CALL handle_error("A problem happened allocating memory for latitudes")
  ! Read latitude values
  status = nf90_get_var(ncid, varid, lat)
  IF (status /= nf90_noerr) CALL handle_error("A problem happened reading latitude values")
    ! Checking latitude units
  status = nf90_get_att(ncid, varid, UNITS, attribute)
  IF (status /= nf90_noerr) CALL handle_error("A problem happened getting latitude units")
  IF (attribute.NE.LATITUDE_UNITS) CALL handle_error("Latitude units must be degrees_north")
  IF (debugging) THEN
     PRINT*, "Size of latitude vector ", ny
     PRINT*, "Latitude units, ", TRIM(attribute)
  END IF

!******** TIME variable ************************************

  ! Obtenemos la identidad de la variable usando su nombre.
  status = nf90_inq_varid(ncid, tname, varid)
  IF (status /= nf90_noerr) CALL handle_error("A problem happened getting time variable id")
  ! Getting ID for dimension of array
  status = nf90_inq_dimid(ncid, tname, DimID)
  IF (status /= nf90_noerr) CALL handle_error("A problem happened getting time dimension id")
  ! How many snapshots are there?
  status = nf90_inquire_dimension(ncid, DimID, len = time_F)
  IF (status /= nf90_noerr) CALL handle_error("A problem happened getting time size")
  !*******************************************
  time_I = 0 !apaño para que rule con mi código
  !*********************************************
  ALLOCATE(time(0:time_F-1),STAT=status)   ! Assigning memory for time vector
  IF (status.NE.0) CALL handle_error("A problem happened allocating memory for latitudes")
  ! Read time values
  status = nf90_get_var(ncid, varid, time)
  IF (status /= nf90_noerr) CALL handle_error("A problem happened reading time values")
  ! Checking time units
  status = nf90_get_att(ncid, varid, UNITS, attribute)
  IF (status /= nf90_noerr) CALL handle_error("A problem happened getting time units")
  IF (debugging) THEN
     PRINT*, "Size of time vector ", time_F
     PRINT*, "Time units, ", TRIM(attribute)
  END IF

!! AHORA LEEMOS U y V **************************************

  ALLOCATE(mivx(0:nx-1,0:ny-1,time_I:time_F), STAT = status) !Reservo memoria para la componente X de la velocidad
    IF (status.NE.0) CALL handle_error("A problem happened allocating memory for U field")
    ALLOCATE(mivy(0:nx-1,0:ny-1,time_I:time_F), STAT = status) !Reservo memoria para la componente Y de la velocidad
      IF (status.NE.0) CALL handle_error("A problem happened allocating memory for V field")
  ALLOCATE(tierra(0:nx-1,0:ny-1), STAT = status)  ! Reservo memoria para la máscara de tierra
  IF (status.NE.0) CALL handle_error("A problem happened allocating memory for land mask")

  DO i=0,nx-1
     DO j=0,ny-1
        tierra(i,j)=.FALSE.   !Lo pongo todo a agua
     END DO
  END DO
  
  

  ALLOCATE(data_in_velo(0:nx-1,0:ny-1,time_I:time_F), STAT = status)
  IF (status.NE.0) CALL handle_error("A problem happened allocating memory before reading U field")

  
  ! Obtenemos la identidad de la variable usando su nombre.
  status = nf90_inq_varid(ncid, uname, varid)
  IF (status /= nf90_noerr) CALL handle_error("A problem happened getting U field ID")
  ! Leemos los datos de velocidad
  status = nf90_get_var(ncid, varid, data_in_velo) 
  IF (status /= nf90_noerr) CALL handle_error("A problem happened reading U field")
  ! Checking U field units
  status = nf90_get_att(ncid, varid, UNITS, attribute)
  IF (status /= nf90_noerr) CALL handle_error("A problem happened getting U field units")
  IF (attribute.NE.VELOCITY_UNITS) CALL handle_error("U field units must be m s-1")
  IF (debugging) THEN
     PRINT*, "Size of U field ", nx,"x",ny,"x",time_F 
     PRINT*, "U field units, ", TRIM(attribute)
  END IF
  DO k= time_I, time_F
     DO i=0, nx-1
        DO j=0, ny-1
           mivx(i,j,k)=DBLE(data_in_velo(i,j,k))
        END DO
     END DO
  END DO

  DEALLOCATE(data_in_velo, STAT = status) ! Liberamos memoria
  IF (status /= 0) CALL handle_error("A problem happened freeing memory after reading U field")

  
  ! Ahora leemos la V
  ALLOCATE(data_in_velo(0:nx-1,0:ny-1,time_I:time_F), STAT = status)
  IF (status.NE.0) CALL handle_error("A problem happened allocating memory before reading V field")
  ! Obtenemos la identidad de la variable usando su nombre.
  status = nf90_inq_varid(ncid, vname, varid) 
  IF (status /= nf90_noerr) CALL handle_error("A problem happened getting V field ID")
  ! Leemos los datos de velocidad
  status = nf90_get_var(ncid, varid, data_in_velo)
  IF (status /= nf90_noerr) CALL handle_error("A problem happened reading V field")
  ! Checking V field units
  status = nf90_get_att(ncid, varid, UNITS, attribute)
  IF (status /= nf90_noerr) CALL handle_error("A problem happened getting V field units")
  IF (attribute.NE.VELOCITY_UNITS) CALL handle_error("V field units must be m s-1")
  IF (debugging) THEN
     PRINT*, "Size of V field ", nx,"x",ny,"x",time_F 
     PRINT*, "V field units, ", TRIM(attribute)
  END IF
  DO k= time_I, time_F
     DO i=0, nx-1
        DO j=0, ny-1
           mivy(i,j,k)=DBLE(data_in_velo(i,j,k))
        END DO
     END DO
  END DO

 
 
  ! Cerramos el archivo y liberamos los recuros que ya no son necesarios.
  status = nf90_close(ncid)
  IF (status /= nf90_noerr) CALL handle_error("A problem happened while closing nc file")
  DEALLOCATE(data_in_velo,STAT = status) ! Liberamos memoria
  IF (status /= 0) CALL handle_error("A problem happened freeing memory after reading V field")

END SUBROUTINE ReadNetCDF


!*******************************************************************
!********** Routine to print error messages ************************
!********** and STOP the program ***********************************
!*******************************************************************
SUBROUTINE Handle_error(message)
  CHARACTER (len = *) :: message

  IF (status .NE. 0) THEN
     PRINT*, message
     PRINT*, "ERROR CODE : ,",status
     STOP
  ENDIF
END SUBROUTINE Handle_error

  
END PROGRAM COSMO_DHT
